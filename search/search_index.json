{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WalledEval Welcome to the WalledEval Documentation! WalledEval is a simple library to test LLM safety by identifying if text generated by the LLM is indeed safe. We purposefully test benchmarks with negative information and toxic prompts to see if it is able to flag prompts of malice. New Version Recently Released We have recently released v0.1.0 of our codebase! This means that our documentation is not completely up-to-date with the current state of the codebase. However, we will be updating our documentation soon for all users to be able to quickstart using WalledEval! Till then, it is always best to consult the code or the tests/ or notebooks/ folders to have a better idea of how the codebase currently works.","title":"Home"},{"location":"#walledeval","text":"Welcome to the WalledEval Documentation! WalledEval is a simple library to test LLM safety by identifying if text generated by the LLM is indeed safe. We purposefully test benchmarks with negative information and toxic prompts to see if it is able to flag prompts of malice. New Version Recently Released We have recently released v0.1.0 of our codebase! This means that our documentation is not completely up-to-date with the current state of the codebase. However, we will be updating our documentation soon for all users to be able to quickstart using WalledEval! Till then, it is always best to consult the code or the tests/ or notebooks/ folders to have a better idea of how the codebase currently works.","title":"WalledEval"},{"location":"llm/","text":"LLMs ( walledeval.llm ) WalledEval's LLM architecture aims to support various kinds of LLMs, which a current focus on Decoder-only and MoE architecures. These LLMs are used as systems-under-test (SUTs) , which allows generating question answers and prompt outputs.","title":"Overview"},{"location":"llm/#llms-walledevalllm","text":"WalledEval's LLM architecture aims to support various kinds of LLMs, which a current focus on Decoder-only and MoE architecures. These LLMs are used as systems-under-test (SUTs) , which allows generating question answers and prompt outputs.","title":"LLMs (walledeval.llm)"},{"location":"llm/huggingface/","text":"HuggingFace LLM Support WalledEval supports a plethora of LLM models accessible through the HuggingFace Hub . This means that any model deployed on HuggingFace under the text-generation task can be loaded up as a SUT. These LLMs can be accessed via the walledeval.llm.HF_LLM class. Here is a quick guide to the HF_LLM class. Initiating HF_LLM HF_LLM(id, system_prompt = \"\", type = LLMType.NEITHER) Initiates LLM from HuggingFace Hub. Parameters: id ( str ): Identifier of LLM from HuggingFace Hub . For example, \"meta-llama/Meta-Llama-3-8B\" . Ensure that the model falls within the task of text-generation . system_prompt ( str , optional ): Default System Prompt for LLM (note: this is overridden if a system prompt is provided by the user in the generation process). Defaults to an empty string. type ( int or LLMType , optional ): Type of LLM to discriminate. Integer values should fall between 0 and 2 to signify the corresponding LLMType value. This is overridden by the instruct field in HF_LLM.generate . By default, this value is LLMType.NEITHER , which means that the user needs to specify during the HF_LLM.generate function or use the specific functions indented for use. Chatting with HF_LLM HF_LLM.chat(text, max_new_tokens = 256, temperature = 0.0) -> str Uses a chat format (provided by the tokenizer) to get the LLM to complete a chat discussion. Parameters: text ( Messages ): Input in either string or list format to generate LLM data. (See the above Input Types subsection for more info regarding the Messages type). If a system prompt is specified at the start, it is used in place of the previously specified System Prompt. max_new_tokens ( int , optional ): Maximum tokens to be generated by the LLM. Per LLM, there is a different range of values for this variable. Defaults to 256. temperature ( float , optional ): Temperature of LLM being queried. This variable is highly dependent on the actual LLM. Defaults to 0. Next-Token Completion HF_LLM.complete(text, max_new_tokens = 256, temperature = 0.0) -> str Uses LLM as a next-token predictor to generate a completion of a piece of text. Parameters: - text ( str ): Input in only string format to generate LLM data. Unlike chat completion, this does not support a chat format as an input. - max_new_tokens ( int , optional ): Maximum tokens to be generated by the LLM. Per LLM, there is a different range of values for this variable. Defaults to 256. - temperature ( float , optional ): Temperature of LLM being queried. This variable is highly dependent on the actual LLM. Defaults to 0. Generic Generation HF_LLM.generate(text, max_new_tokens = 256, temperature = 0.0, instruct = None) -> str Merges the chat and complete methods into a single method to simplify accessing the generation defaults. text ( Messages ): Input in either string or list format to generate LLM data. (See the above Input Types subsection for more info regarding the Messages type). If this is indeed a completion, any list input will throw a ValueError . If a system prompt is specified at the start, it is used in place of the previously specified System Prompt. max_new_tokens ( int , optional ): Maximum tokens to be generated by the LLM. Per LLM, there is a different range of values for this variable. Defaults to 256. temperature ( float , optional ): Temperature of LLM being queried. This variable is highly dependent on the actual LLM. Defaults to 0. instruct ( bool or None , optional ): Optional flag to change behaviour of generate command. This overrides the input type parameter at instantiation. Defaults to None (i.e. it uses the type parameter at instantiation).","title":"HuggingFace LLM Support"},{"location":"llm/huggingface/#huggingface-llm-support","text":"WalledEval supports a plethora of LLM models accessible through the HuggingFace Hub . This means that any model deployed on HuggingFace under the text-generation task can be loaded up as a SUT. These LLMs can be accessed via the walledeval.llm.HF_LLM class. Here is a quick guide to the HF_LLM class.","title":"HuggingFace LLM Support"},{"location":"llm/huggingface/#initiating-hf_llm","text":"HF_LLM(id, system_prompt = \"\", type = LLMType.NEITHER) Initiates LLM from HuggingFace Hub. Parameters: id ( str ): Identifier of LLM from HuggingFace Hub . For example, \"meta-llama/Meta-Llama-3-8B\" . Ensure that the model falls within the task of text-generation . system_prompt ( str , optional ): Default System Prompt for LLM (note: this is overridden if a system prompt is provided by the user in the generation process). Defaults to an empty string. type ( int or LLMType , optional ): Type of LLM to discriminate. Integer values should fall between 0 and 2 to signify the corresponding LLMType value. This is overridden by the instruct field in HF_LLM.generate . By default, this value is LLMType.NEITHER , which means that the user needs to specify during the HF_LLM.generate function or use the specific functions indented for use.","title":"Initiating HF_LLM"},{"location":"llm/huggingface/#chatting-with-hf_llm","text":"HF_LLM.chat(text, max_new_tokens = 256, temperature = 0.0) -> str Uses a chat format (provided by the tokenizer) to get the LLM to complete a chat discussion. Parameters: text ( Messages ): Input in either string or list format to generate LLM data. (See the above Input Types subsection for more info regarding the Messages type). If a system prompt is specified at the start, it is used in place of the previously specified System Prompt. max_new_tokens ( int , optional ): Maximum tokens to be generated by the LLM. Per LLM, there is a different range of values for this variable. Defaults to 256. temperature ( float , optional ): Temperature of LLM being queried. This variable is highly dependent on the actual LLM. Defaults to 0.","title":"Chatting with HF_LLM"},{"location":"llm/huggingface/#next-token-completion","text":"HF_LLM.complete(text, max_new_tokens = 256, temperature = 0.0) -> str Uses LLM as a next-token predictor to generate a completion of a piece of text. Parameters: - text ( str ): Input in only string format to generate LLM data. Unlike chat completion, this does not support a chat format as an input. - max_new_tokens ( int , optional ): Maximum tokens to be generated by the LLM. Per LLM, there is a different range of values for this variable. Defaults to 256. - temperature ( float , optional ): Temperature of LLM being queried. This variable is highly dependent on the actual LLM. Defaults to 0.","title":"Next-Token Completion"},{"location":"llm/huggingface/#generic-generation","text":"HF_LLM.generate(text, max_new_tokens = 256, temperature = 0.0, instruct = None) -> str Merges the chat and complete methods into a single method to simplify accessing the generation defaults. text ( Messages ): Input in either string or list format to generate LLM data. (See the above Input Types subsection for more info regarding the Messages type). If this is indeed a completion, any list input will throw a ValueError . If a system prompt is specified at the start, it is used in place of the previously specified System Prompt. max_new_tokens ( int , optional ): Maximum tokens to be generated by the LLM. Per LLM, there is a different range of values for this variable. Defaults to 256. temperature ( float , optional ): Temperature of LLM being queried. This variable is highly dependent on the actual LLM. Defaults to 0. instruct ( bool or None , optional ): Optional flag to change behaviour of generate command. This overrides the input type parameter at instantiation. Defaults to None (i.e. it uses the type parameter at instantiation).","title":"Generic Generation"},{"location":"llm/input_types/","text":"Input Types We have added support for several types of input formats in LLMs (with more on the way!) to make our library easily extensible and usable. Our LLM architecture supports the following input types: Input Type Format Example str \"text to ask LLM as user\" \"Hi, how are you today?\" list[dict[str, str]] List of dictionary objects with the following keys: \"role\" : Either one of \"system\" , \"user\" , \"assistant\" . \"content\" : Any string or alternative input supported by the model tokenizer. [ {\"role\": \"system\", \"content\": \"You are a helpful assistant\"}, {\"role\": \"user\", \"content\": \"Hi, how are you today?\"} ] list[walledeval.types.Message] Similar to above, except the dictionary object is wrapped within a custom Pydantic model class [ Message(role=\"system\", content=\"You are a helpful assistant\"), Message(role=\"user\", content=\"Hi, how are you today?\") ] These are supported under an encompassing walledeval.types.Messages class. The supported LLMs convert these into recognizable formats for the LLM to generate based on. Certain class methods cannot support some of these formats due to their expected formats.","title":"Input Types"},{"location":"llm/input_types/#input-types","text":"We have added support for several types of input formats in LLMs (with more on the way!) to make our library easily extensible and usable. Our LLM architecture supports the following input types: Input Type Format Example str \"text to ask LLM as user\" \"Hi, how are you today?\" list[dict[str, str]] List of dictionary objects with the following keys: \"role\" : Either one of \"system\" , \"user\" , \"assistant\" . \"content\" : Any string or alternative input supported by the model tokenizer. [ {\"role\": \"system\", \"content\": \"You are a helpful assistant\"}, {\"role\": \"user\", \"content\": \"Hi, how are you today?\"} ] list[walledeval.types.Message] Similar to above, except the dictionary object is wrapped within a custom Pydantic model class [ Message(role=\"system\", content=\"You are a helpful assistant\"), Message(role=\"user\", content=\"Hi, how are you today?\") ] These are supported under an encompassing walledeval.types.Messages class. The supported LLMs convert these into recognizable formats for the LLM to generate based on. Certain class methods cannot support some of these formats due to their expected formats.","title":"Input Types"},{"location":"llm/llm_types/","text":"LLM Types Our LLM architecture supports two types of models: INSTRUCT and BASE . The distinction between these two model types is as follows: LLM Type Function Corresponding Number BASE Next-token predictor LLMs that support text completion but are not tuned for chatting and role-based conversation. 0 INSTRUCT Instruction-tuned / Chat-tuned LLMs that can take in a chat format and generate text for an assistant. 1 These types fall under the walledeval.types.LLMType enumeration class, and we support a NEITHER flag (with corresponding number 2 ) to ensure the LLM does not discriminate between types.","title":"LLM Types"},{"location":"llm/llm_types/#llm-types","text":"Our LLM architecture supports two types of models: INSTRUCT and BASE . The distinction between these two model types is as follows: LLM Type Function Corresponding Number BASE Next-token predictor LLMs that support text completion but are not tuned for chatting and role-based conversation. 0 INSTRUCT Instruction-tuned / Chat-tuned LLMs that can take in a chat format and generate text for an assistant. 1 These types fall under the walledeval.types.LLMType enumeration class, and we support a NEITHER flag (with corresponding number 2 ) to ensure the LLM does not discriminate between types.","title":"LLM Types"},{"location":"llm/other_api/","text":"Other API Support WalledEval also currently supports the following alternative LLM types: Class LLM Type Claude(model_id, api_key, system_prompt = \"\", type = LLMType.NEITHER) Claude 3 ( Claude.haiku , Claude.sonnet and Claude.opus class methods exist to initiate the most recent versions of each of these models)","title":"Other API Support"},{"location":"llm/other_api/#other-api-support","text":"WalledEval also currently supports the following alternative LLM types: Class LLM Type Claude(model_id, api_key, system_prompt = \"\", type = LLMType.NEITHER) Claude 3 ( Claude.haiku , Claude.sonnet and Claude.opus class methods exist to initiate the most recent versions of each of these models)","title":"Other API Support"},{"location":"llm/supporting_your_own/","text":"Supporting your own LLMs Assuming one cannot put up their models on HuggingFace Hub, they can also define their own classes to add support for their own LLMs using the abstract llm.LLM class. To support your own LLMs, you can extend this class and implement the following methods: __init__ : Instantiates the LLM, calls superclass instantiation complete(text: str, max_new_tokens: int = 256, temperature: float = 0.0) -> str : Completion of text string chat(text: Messages, max_new_tokens: int = 256, temperature: float = 0.0) -> str : Allows chatting Here is an example of a dummy class defined to inherit the LLM class, which only supports next-token prediction. from walledeval.llm import LLM from walledeval.types import LLMType , Messages class DummyLLM ( LLM ): def __init__ ( self ): super () . __init__ ( name = \"DummyLLM\" , system_prompt = \"\" , type = LLMType . BASE ) def complete ( self , text : str , max_new_tokens : int = 256 , temperature : float = 0.0 ) -> str : return text [: max_new_tokens ] def chat ( self , text : Messages , max_new_tokens : int = 256 , temperature : float = 0.0 ) -> str : raise NotImplementedError ( \"DummyLLM does not support chat completion!\" )","title":"Supporting your own LLMs"},{"location":"llm/supporting_your_own/#supporting-your-own-llms","text":"Assuming one cannot put up their models on HuggingFace Hub, they can also define their own classes to add support for their own LLMs using the abstract llm.LLM class. To support your own LLMs, you can extend this class and implement the following methods: __init__ : Instantiates the LLM, calls superclass instantiation complete(text: str, max_new_tokens: int = 256, temperature: float = 0.0) -> str : Completion of text string chat(text: Messages, max_new_tokens: int = 256, temperature: float = 0.0) -> str : Allows chatting Here is an example of a dummy class defined to inherit the LLM class, which only supports next-token prediction. from walledeval.llm import LLM from walledeval.types import LLMType , Messages class DummyLLM ( LLM ): def __init__ ( self ): super () . __init__ ( name = \"DummyLLM\" , system_prompt = \"\" , type = LLMType . BASE ) def complete ( self , text : str , max_new_tokens : int = 256 , temperature : float = 0.0 ) -> str : return text [: max_new_tokens ] def chat ( self , text : Messages , max_new_tokens : int = 256 , temperature : float = 0.0 ) -> str : raise NotImplementedError ( \"DummyLLM does not support chat completion!\" )","title":"Supporting your own LLMs"},{"location":"setup/installation/","text":"Installation Installing from PyPI Yes, we have published WalledEval on PyPI! To install WalledEval and all its dependencies, the easiest method would be to use pip to query PyPI. This should, by default, be present in your Python installation. To, install run the following command in a terminal or Command Prompt / Powershell: $ pip install walledeval Depending on the OS, you might need to use pip3 instead. If the command is not found, you can choose to use the following command too: $ python -m pip install walledeval Here too, python or pip might be replaced with py or python3 and pip3 depending on the OS and installation configuration. If you have any issues with this, it is always helpful to consult Stack Overflow . Installing from Source To install from source, you need to get the following: Git Git is needed to install this repository. This is not completely necessary as you can also install the zip file for this repository and store it on a local drive manually. To install Git, follow this guide . After you have successfully installed Git, you can run the following command in a terminal / Command Prompt etc: $ git clone https://github.com/walledai/walledeval.git This stores a copy in the folder walledeval . You can then navigate into it using cd walledeval . Poetry This project can be used easily via a tool known as Poetry. This allows you to easily reflect edits made in the original source code! To install poetry , you can also install it using pip by typing in the command as follows: $ pip install poetry Again, if you have any issues with pip , check out here . After this, you can use the following command to install this library: $ poetry install","title":"Installation"},{"location":"setup/installation/#installation","text":"","title":"Installation"},{"location":"setup/installation/#installing-from-pypi","text":"Yes, we have published WalledEval on PyPI! To install WalledEval and all its dependencies, the easiest method would be to use pip to query PyPI. This should, by default, be present in your Python installation. To, install run the following command in a terminal or Command Prompt / Powershell: $ pip install walledeval Depending on the OS, you might need to use pip3 instead. If the command is not found, you can choose to use the following command too: $ python -m pip install walledeval Here too, python or pip might be replaced with py or python3 and pip3 depending on the OS and installation configuration. If you have any issues with this, it is always helpful to consult Stack Overflow .","title":"Installing from PyPI"},{"location":"setup/installation/#installing-from-source","text":"To install from source, you need to get the following:","title":"Installing from Source"},{"location":"setup/installation/#git","text":"Git is needed to install this repository. This is not completely necessary as you can also install the zip file for this repository and store it on a local drive manually. To install Git, follow this guide . After you have successfully installed Git, you can run the following command in a terminal / Command Prompt etc: $ git clone https://github.com/walledai/walledeval.git This stores a copy in the folder walledeval . You can then navigate into it using cd walledeval .","title":"Git"},{"location":"setup/installation/#poetry","text":"This project can be used easily via a tool known as Poetry. This allows you to easily reflect edits made in the original source code! To install poetry , you can also install it using pip by typing in the command as follows: $ pip install poetry Again, if you have any issues with pip , check out here . After this, you can use the following command to install this library: $ poetry install","title":"Poetry"}]}